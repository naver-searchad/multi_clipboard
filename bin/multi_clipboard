#!/bin/bash

################################################################################
# Multi Clipboard for GNU screen!
# *** Utility to keep multiple clipboards ***
# *** and manage screen's clipboard.      ***
#
# More information: https://raw.github.com/rcmdnk/multi_clipboard
################################################################################

#The MIT License (MIT) {{{
#
#Copyright (c) 2013 rcmdnk
#
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#}}}

usage="
Usage:

  $ multi_clipboard -i [args]
  # Push [args]to the clipboard list

  $ multi_clipboard -I
  # Push the screen's clipboard to the clipboard list

  $ multi_clipboard -o
  # Will show the clipboard list, then select one, which will be placed
  # the top of the clipboard list.

  $ multi_clipboard -O
  # Same as -o, in addition, send it to the screen's clipboard

  $ multi_clipboard -s [args]
  # Send [args] to the screen's clipboard

  $ multi_clipboard -S
  # Use in screen for selection mode.

  $ multi_clipboard -w # or w/o any other options
  # Launch selection window

  $ multi_clipboard -W
  # Same as -w, in addition, send it to the screen's clipboard

  $ multi_clipboard -x
  # Send the last clipboard to the clipboard of OS (X server)
  # Even if CLX is not set, it uses CLXOS, is available

  $ multi_clipboard -c
  # Clean up clipboard file

  $ multi_clipboard snippet [option]
  # Use 'snippet' file instead of saved clipboards.

  $ multi_clipboard -h
  # Show this usage
"

# Settings for screen {{{
#
# To use in screen, put this script where
# PATH is set , and write in .screenrc:
#

# ----------.screenrc---------
## Screen exchange file
#bufferfile "$SCREENEXCHANGE" # SCREENEXCHANGE must be set in .bashrc !!!
#
#
## Overwrite keys in copy mode
#bindkey -m ' ' eval 'stuff \040' 'writebuf' 'exec !!! multi_clipboard -I'
#bindkey -m Y eval 'stuff Y' 'writebuf' 'exec !!! multi_clipboard -I'
#bindkey -m W eval 'stuff W' 'writebuf' 'exec !!! multi_clipboard -I'
#
#
## Selection mode
## C-a a : default is meta (Send the command character (C-a) to window.)
## C-a C-a : default is other (Toggle the window displayed previously.)
#bind a eval 'command -c mc' 'exec multi_clipboard -S'
#bind ^a eval 'command -c mc' 'exec multi_clipboard -S'
#
## Next
#bind -c mc n eval 'command -c mc' 'exec multi_clipboard -S -n'
#bind -c mc ^n eval 'command -c mc' 'exec multi_clipboard -S -n'
#
## Previous
#bind -c mc p eval 'command -c mc' 'exec multi_clipboard -S -p'
#bind -c mc ^p eval 'command -c mc' 'exec multi_clipboard -S -p'
#
## Quit
#bind -c mc q eval 'exec multi_clipboard -S -q'
#bind -c mc ^q eval 'exec multi_clipboard -S -q'
#
## Choose and Quit
#bind -c mc ' ' eval 'exec multi_clipboard -S -s'
#
#
## Launch selection window
## C-a q : default is xon (Send a control-q to the current window.)
#bind q screen -t multi_clipboard -p - multi_clipboard -W
# ----------.screenrc---------

#
# These settings enable that a clipboard copied by SPACE, Y and  W
# in the copy mode will be sent to the clipboard list.
# If CLX is set, it is also sent to the OS's (X server's) clipboard.
#
# C-a a (C-a) can be used to select a clipboard from the list,
# instead of using multi_clipboard -O.
# Once you input C-a a, current clipboard is shown in the message line like:
#
#     0: current_clipboard
#
# You can choose next and previous candidate by n and p, respectively.
# Use space to select a shown clipbaord.
# Use q to quit.
#
# C-a q will launch new window for selecting the clipboard.
#
# And set environmental variables in .bashrc
# ----------.bashrc---------
# export SCREENEXCHANGE=$HOME/.screen-exchange
# export SCREEN_MSGMINWAIT=1
# export CLIPBOARD=$HOME/.clipboard
# export CLMAXHIST=20
# export CLSEP="" # "" was inserted with "C-v C-g", use bell as a separator
# export CLX="" #xsel/xclip
# if [[ "$OSTYPE" =~ "linux" ]];then
#   if which -s xsel;then
#     export CLXOS="xsel"
#   elif which -s xsel;then
#     export CLXOS="xclip"
#   fi
# elif [[ "$OSTYPE" =~ "cygwin" ]];then
#   if which -s putclip;then
#     export CLXOS="putclip"
#   elif which -s xsel;then
#     export CLXOS="xsel"
#   elif which -s xsel;then
#     export CLXOS="xclip"
#   fi
# elif [[ "$OSTYPE" =~ "darwin" ]];then
#   if which -s pbcopy;then
#     export CLXOS="pbcopy"
#   fi
# fi
# ----------.bashrc---------
#
#
# Note 1): SCREENEXCHANGE must be set in .bashrc
#          or you must remove the bufferfile definition line from .screenrc
#          In the later case, /tmp/screen-exchange will be used.
#
# Note 2): SCREEN_MSGMINWAIT is used to revert msgminwait in screen
#          because multi_clipboard temporally change it to 0.
#          Default value in both screen and multi_clipboard is 1.
#          Therefore, you don't need to set SCREEN_MSGMINWAIT
#          unless you set msgminwait in .screenrc.
# }}}

# Set valuse {{{
# Following variables can be set in .bashrc or else
#
# CLIPBOARD, SCREENEXCHANGE, CLMAXHIST, CLX, CLXOS, CLSEP
# (Refer default values below)

# File to keep clipboards
clb=${CLIPBOARD:-$HOME/.clipboard}

# File for snippet
snp=${MCSNIPPET:-$HOME/.mcsnippet}

# Flag clb or snp?
is_clb=1

# File for use
f_use=$clb

# File for screen's clipboard
scex=${SCREENEXCHANGE:-/tmp/screen-exchange}

# Max number of clipboards to keep
max=${CLMAXHIST:-20}

# Application to sent the clipboard to the OS's clipboard
# If blank, don't copy the clipboard to the OS's clipboard
# other than when "-x" is given
clx=${CLX:-""}

# Application to sent the clipboard to the OS's clipboard
# to be used for "-x" option
if [ "$CLXOS" != "" ];then
  clxos=${CLXOS}
elif [[ "$OSTYPE" =~ "linux" ]];then
  if which xsel >/dev/null 2>&1;then
    clxos="xsel"
  elif which xsel >/dev/null 2>&1;then
    clxos="xclip"
  fi
elif [[ "$OSTYPE" =~ "cygwin" ]];then
  if which putclip >/dev/null 2>&1;then
    clxos="putclip"
  elif which xsel >/dev/null 2>&1;then
    clxos="xsel"
  elif which xsel >/dev/null 2>&1;then
    clxos="xclip"
  fi
elif [[ "$OSTYPE" =~ "darwin" ]];then
  if which pbcopy >/dev/null 2>&1;then
    clxos="pbcopy"
  fi
fi

# Separator of clipboards in the file
cls="${CLSEP:-}"

# Default msgminwait
msgminwait="${SCREEN_MSGMINWAIT:-1}"

# }}}

function mccopy2cl { # {{{
  # Copy to clipboard of X
  if [ "$clx" != "" ];then
    echo -en "$*" | $clx
  fi
} # }}}

function mcgetcls { # {{{
  # Get old words
  local orig_ifs=$IFS
  IFS="$cls"
  touch $f_use
  clbs=(`cat $f_use`)
  IFS=$orig_ifs
  nclbs=${#clbs[@]}
} # }}}

function mcaligncls { # {{{
  local n=${1:-0}
  # Don't align for snippet
  if [ $is_clb -eq 0 ];then
    n=0
  fi
  local c="${clbs[$n]}"
  echo -en "$c$cls" > $f_use
  for((i=0; i<nclbs; i++));do
    if [ ! $i -eq $n ];then
      echo -en "${clbs[$i]}$cls" >> $f_use
    fi
  done
} # }}}

function mcdelete { # {{{
  local n=${1:-$((${#clbs[@]}-1))}
  unset clbs[$n]
  rm -f $f_use
  for c in "${clbs[@]}";do
    echo -en "$c$cls" >> $f_use
  done
  mcgetcls
} # }}}

function mcpush { # {{{
  # Set input
  local input="$*"

  # Ignore blank
  if [ "$input" = "" ];then
    return
  fi

  # Renew words
  mcgetcls
  local i=0
  local j=1
  echo -en "$input$cls" > $f_use
  while [ $i -lt $nclbs ] && [ $j -lt $max ] ;do
    local iuse=$i
    ((i++))

    # Remove duplications
    if [ "$input" = "${clbs[$iuse]}" ];then
      continue
    fi
    echo -en "${clbs[$iuse]}$cls" >> $f_use
    j=$((j+1))
  done

  # Copy to clipboard of X
  mccopy2cl "$input"
} # }}}

function mcpushsc { # {{{
  touch $scex
  mcpush "$(cat $scex)"
} # }}}

function mcpop { # {{{
  ## Show stored words
  mcgetcls
  if [ $nclbs -eq 0 ];then
    printf "No clipboards in $f_use\n\n"
    return
  fi
  echo
  for((i=$((nclbs-1)); i>=0; i--));do
    if [ $(echo "${clbs[$i]}"|wc -l) -ge 3 ];then
      local clbshow="$(echo "${clbs[$i]}"|head -n2)
..."
    else
      local clbshow="${clbs[$i]}"
    fi
    # %%/\\ is reduced to %/\ during the conversions
    # \e\" makes problem (stop the output), then \ must be conveted to the output
    # `\\` is converted to one \ for the real clipboard, too, to be fixed.
    local clbshow=$(echo "$clbshow" |perl -pe 's/\n/\n    /g' |perl -pe 's/    $//g' |perl -pe 's/%/%%/g'|perl -pe 's/\\/\\\\/g')
    printf "%2d: $clbshow\n" $((i+1))
  done

  # Choose buffer
  printf "\nchoose buffer: "
  read n
  if [ "$n" = "q" ];then
    return 0
  fi
  if ! echo $n|grep -q "^[1-9][0-9]*$" || [ "$n" -gt "$nclbs" ];then
    echo "$f is not valid"
    echo "Enter [1-$((nclbs))] or q (to quit)"
    return 1
  fi
  # Subtract one to adjust for the array
  ((n--))

  # Align clipboards
  mcaligncls $n

  # Copy to clipboard of X
  mccopy2cl "${clbs[$n]}"
} # }}}

function mcpopsc { # {{{
  screen -X msgminwait 0
  mcgetcls
  echo -en "${clbs[0]}" > $scex
  screen -X readbuf
  printf "\e^Clipbaord: ${clbs[0]: 0:480}\e\\"
  screen -X msgminwait $msgminwait
} # }}}

function mcpoponsc_messaage { # {{{
  # Note: Message line can show only 512 characters.
  # If more than 512 characters were given to the message line,
  # the message can't be correctly shown (and overflows will appear in the window)
  #printf "\e^n/p(next/prev) q(quit) Space(select) %2d: $clbshow\e\\" $mcpoponsc_n
  screen -X echo '$mcpoponsc_n/$nclbs: $clb_'$((mcpoponsc_n-1))
} # }}}

function mcpoponsc { # {{{
  screen -X msgminwait 0
  # Get stored words
  mcgetcls

  # Check a number of clipboards
  if [ $nclbs -eq 0 ];then
    printf "\eNo clipboards in $f_use\e\\"
    sleep 1
    return
  fi

  screen -X setenv nclbs $nclbs
  for ((i=0; i<$nclbs; i++));do
    # screen's command must be less than 512 in total, including setenv ....
    # Therefore stored value should be much shorter 512.
    local clbshow="${clbs[$i]: 0: 480}"
    screen -X setenv "clb_${i}" "$clbshow"
  done

  # mcpoponsc_n starts from 1
  # It is better to use same number for pringing in mcpoponsc_messaage,
  # because setenv command also show a message in a short time.
  # If they are different, there will be ugly flash.
  mcpoponsc_n=1
  screen -X setenv mcpoponsc_n $mcpoponsc_n
  mcpoponsc_messaage
  screen -X msgminwait $msgminwait
} # }}}

function mcpoponsc_next { # {{{
  screen -X msgminwait 0
  local mcpoponsc_n=$(screen -Q echo '$mcpoponsc_n')
  local nclbs=$(screen -Q echo '$nclbs')
  if [ $mcpoponsc_n -eq 1 ];then
    mcpoponsc_n=$((nclbs))
  else
    ((mcpoponsc_n--))
  fi
  screen -X setenv mcpoponsc_n $mcpoponsc_n
  mcpoponsc_messaage
  screen -X msgminwait $msgminwait
} # }}}

function mcpoponsc_prev { # {{{
  screen -X msgminwait 0
  local mcpoponsc_n=$(screen -Q echo '$mcpoponsc_n')
  local nclbs=$(screen -Q echo '$nclbs')
  if [ $mcpoponsc_n -eq $((nclbs)) ];then
    mcpoponsc_n=1
  else
    ((mcpoponsc_n++))
  fi
  screen -X setenv mcpoponsc_n $mcpoponsc_n
  mcpoponsc_messaage
  screen -X msgminwait $msgminwait
} # }}}

function mcpoponsc_quit { # {{{
  screen -X msgminwait 0
  for ((i=0; i<$(screen -Q echo '$nclbs'); i++));do
    screen -X unsetenv clb_$i
  done
  screen -X echo ""
  screen -X unsetenv mcpoponsc_n
  screen -X unsetenv nclbs
  screen -X msgminwait $msgminwait
} # }}}

function mcpoponsc_select { # {{{
  screen -X msgminwait 0
  mcgetcls

  mcpoponsc_n=$(screen -Q echo '$mcpoponsc_n')
  local n=$((mcpoponsc_n-1))

  # Align clipboards
  mcaligncls $n

  # Copy to clipboard of X
  mccopy2cl "${clbs[$n]}"

  # Finalize
  mcpoponsc_quit

  # Pop Clipboard
  mcpopsc

  screen -X msgminwait $msgminwait
} # }}}

function mcpopwindow_exit { # {{{
  # clear after selection
  clear

  # Show cursor
  tput cnorm 2>/dev/null || tput vs 2>/dev/null

  # Restore display
  tput rmcup 2>/dev/null || tput te 2>/dev/null

  # Enable echo input
  stty echo
} # }}}

function mcpopwindow_printline () { # is_select row n_clb {{{
  local clbshow="$(echo ${clbs[$3]}|tr '\n' ' ')"
  tput cup $(($2)) 0
  if [ $1 -eq 1 ];then
    printf "\e[7m%3d: ${clbshow: 0: $((cols-5))}\e[m" $(($3+1))
  else
    printf "%3d: ${clbshow: 0: $((cols-5))}" $(($3+1))
  fi
  tput cup $(($2)) 0
} # }}}

function mcpopwindow_printall () { # {{{
  local offset=0
  local select=0
  if [ $# -gt 0 ];then
    offset=$1
    if [ $# -gt 1 ];then
      select=$2
    fi
  fi

  clear

  # Header
  echo "$header"

  for ((i=0; i<$((max_show)); i++));do
    if [ $((i+offset)) -eq $select ];then
      mcpopwindow_printline 1 $((i+ext_row)) $((i+offset))
    else
      mcpopwindow_printline 0 $((i+ext_row)) $((i+offset))
    fi
  done
} # }}}

function mcpopwindow_setheader () { # {{{
  # Set variables
  if [ $is_clb ];then
    header=" $nclbs clipboards in total
    j(down), k(up), d(delete), s(snippet), Enter(select), q(exit)
"
  else
    header=" $nclbs snippets in total
    j(down), k(up), d(delete), Enter(select), q(exit)
"
  fi

  ext_row=$(echo "$header"|wc -l)
  lines=$(tput lines)
  cols=$(tput cols)
  max_show=$nclbs
  if [ $nclbs -gt $((lines-ext_row)) ];then
    max_show=$((lines-ext_row))
  fi
} # }}}

function mcpopwindow { # {{{
  mcgetcls

  # Check a number of clipboards
  if [ $nclbs -eq 0 ];then
    printf "No clipboards in $f_use\n\n"
    sleep 1
    return
  fi

  # Set trap
  trap mcpopwindow_exit 0

  # Hide cursor
  tput civis 2>/dev/null || tput vi 2>/dev/null

  # Save current display
  tput smcup 2>/dev/null || tput ti 2>/dev/null

  # Hide any input (need to cleanup a print, especially when re-draw with printall.)
  stty -echo

  # First view
  mcpopwindow_setheader
  mcpopwindow_printall

  # Select clipboard
  local n=0
  local n_offset=0
  local cursor_r=$ext_row
  tput cup $cursor_r 0

  while : ;do
    read -s -n 1 c
    case $c in
      "j" )
        if [ $n -eq $((nclbs-1)) ];then
          continue
        elif [ $cursor_r -eq $((lines-1)) ];then
          ((n_offset++));((n++))
          mcpopwindow_printall $n_offset $n
        else
          mcpopwindow_printline 0 $((cursor_r)) $n
          ((cursor_r++));((n++))
          mcpopwindow_printline 1 $((cursor_r)) $n
        fi
        ;;
      "k" )
        if [ $cursor_r -ne $ext_row ];then
          mcpopwindow_printline 0 $((cursor_r)) $n
          ((cursor_r--));((n--))
          mcpopwindow_printline 1 $((cursor_r)) $n
        elif [ $n_offset -gt 0 ];then
          ((n_offset--));((n--))
          mcpopwindow_printall $n_offset $n
        else
          continue
        fi
        ;;
      "d" )
        mcdelete $n
        # Check a number of clipboards
        if [ $nclbs -eq 0 ];then
          clear
          printf "No clipboards in $f_use\n\n"
          sleep 1
          return 0
        fi
        if [ $n -eq $nclbs ];then
          if [ $n_offset -gt 0 ];then
            ((n_offset--));((n--))
          else
            ((cursor_r--));((n--))
          fi
        fi
        mcpopwindow_setheader
        mcpopwindow_printall $n_offset $n
        ;;
      "s" )
        if [ $is_clb -eq 0 ];then
          continue
        fi
        c_use="${clbs[$n]}"
        f_use=$snp
        mcpush "$c_use"
        f_use=$clb
        mcgetcls
        ;;
      "q" ) return 0;;
      ""  ) break;;
      "*" ) continue;;
    esac
  done

  # Align clipboards
  mcaligncls $n

  # Copy to clipboard of X
  mccopy2cl "${clbs[$n]}"

} # }}}

function mcpushx { # {{{
  clx=${clx:-${clxos}}
  if [ ! "$clx" ];then
    echo "No clip board application is assigned!"
    return
  fi
  mcgetcls
  echo -en "${clbs[0]}" | $clx
} # }}}

# Check arguments and execute commands{{{
if [ "$1" = "snippet" ];then
  is_clb=0
  f_use=$snp
  shift
fi
if [ "$1" = "-h" ];then
  echo "$usage"
elif [ "$1" = "-s" ];then
  # pushpopsc
  shift
  mcpush "$*"
  mcpopsc
elif [ "$1" = "-S" ];then
  # poponsc
  shift
  if [ "$1" = "" ];then
    mcpoponsc
  elif [ "$1" = "-n" ];then
    mcpoponsc_next
  elif [ "$1" = "-p" ];then
    mcpoponsc_prev
  elif [ "$1" = "-s" ];then
    mcpoponsc_select
  elif [ "$1" = "-q" ];then
    mcpoponsc_quit
  fi
  shift
elif [ "$1" = "-x" ];then
  # pushpopsc
  shift
  mcpushx
elif [ "$1" = "-i" ];then
  # push
  shift
  mcpush "$*"
elif [ "$1" = "-I" ];then
  # pushsc
  shift
  mcpushsc
elif [ "$1" = "-c" ];then
  # cleanup store file
  echo "echo > $f_use"
  echo > $f_use
elif [ "$1" = "-o" ];then
  # pop
  shift
  mcpop
elif [ "$1" = "-O" ];then
  # popsc
  shift
  mcpop
  ret=$?
  if [ $ret -ne 0 ];then
    exit $ret
  fi
  mcpopsc
elif [ "$1" = "-W" ];then
  # mcpopwindow for screen
  shift
  mcpopwindow
  mcpopsc
else # -w or else
  # mcpopwindow
  mcpopwindow
fi # }}}
